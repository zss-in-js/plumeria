---
title: 'üí´ Insentives'
description: 'Plumeria thoughts good to know when using CSS-in-JS solutions'
---

## Ease of introduction

The Plumeria mechanism scans and compiles cssx method define using an AST (Abstract Syntax Tree).
This allows it to operate in a Node.js environment where TypeScript can be executed.  
This is not dependent on any specific framework.

### Easy setup

The learning curve is very gentle.
It works with zero configuration in Vite by default.  
In Next.js set a `<ServerCSS />` component and just compile with `npx css`.

### Simple API

To be able to use the existing className API, the main methods create only return string.
The rest are just the global method for writing global css.

These are very concise and easy to handle, so you can start writing without much reference to the documentation.

## Static style

Plumeria does not support dynamic variable embedding.

### Avoiding complexity

‚úîÔ∏è Minimize the size of the library by reducing the cost of developing unnecessary APIs.

Implementing complex features significantly reduces the library's performance and user and developer experience.
In other words, doing difficult things itself is not favorable for both the library and the developer experience.

### Complete staticness

‚úîÔ∏è Compatible with static site generators and server-side caching strategies.

In Plumeria, styles are statically determined.
CSS is definite at compile time, providing a fully static CSS solution.
You can create maintainable, scalable, definite, and easy-to-manage CSS.

### Pre compilation

Plumeria's compilation logic is not coupled with the framework's build.
The fully independent compilation process does not interfere with the framework's build process, allowing CSS to be safely and deterministically
included in the build process.

### Debugging

Since all styles are resolved at compile time, runtime uncertainties are completely eliminated.
Statically determined CSS allows developers to identify all style issues at compile time.

### Performance

By excluding runtime styles, we naturally keep the cost occurrence to "zero runtime".
There's no need to calculate or resolve styles at runtime. The performance will be finalized.

### Optimization

Style objects passed across component boundaries are all Tree shaking at build time.
Production bundle size does not include objects, and only lightweight CSS remains.

## Universally

The create method takes the key as the class name and gives a 7-character hash of the object at the end.
Class names are changed by objects, but when objects are determined, class names become universal.
Therefore, when methods are determined, class names can be used as CSS Syntax arguments (has and not, where eg.)
The same object hash and the same key are used in both development and production environments,
Developers can easily find it.
