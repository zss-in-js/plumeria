---
title: createComposite
description: Create named modifier classes for a base style.
---

import { Tab, Tabs } from 'fumadocs-ui/components/tabs';

The `createComposite` function allows you to define **modifier classes** based on a base style object.  
This helps keep your base styles clean while still supporting interactive variants like hover or active.

Use it to create structured, reusable style compositions for complex components.

## üîß Example: Flexbox with modifiers

```ts title="TypeScript"
import { css, ps } from '@plumeria/core'

const styles = css.create({
  flexBox: {
    display: 'flex',
    flexDirection: 'column',
    justifyContent: 'center',
  },
});

const composed = css.createComposite(styles.flexBox, {
  hover: {
    [ps.hover]: {
      scale: 1.5,
    },
  },
  active: {
    [ps.active]: {
      color: css.color.gray,
    },
  },
});

function Box() {
  return (
    <>
      <div className={composed.hover} />
      <div className={composed.active} />
    </>
  )
}
```



## üß† Why use `createComposite()`?
- Enables reusable, composable modifiers without duplicating base styles
- Encourages consistent, predictable modifier names like hover, active, focus, etc.
- Grows gently and linearly ‚Äî like Atomic CSS ‚Äî where shared logic doesn't increase output size
- Works seamlessly with `css.create()` and `css.pseudo`, keeping all logic declarative and type-safe

## üìå Tip

You can combine it with utility classes or `defineTheme()` output to create flexible, scalable component styles.

```ts
const modifiers = css.createComposite(styles.buttonBase, {
  hover: {
    [ps.hover]: {
      background: theme.accent,
    },
  },
});
```

## ‚ö†Ô∏è Beware of circular references
If modules reference each other circularly, the compiler will fail to compile them correctly.
This design encourages a local, linear style structure that's easier to understand, faster to compile, and less error-prone across large codebases and bundlers like **rscute**.