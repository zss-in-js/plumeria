const fs = require('fs');
const path = require('path');

const originalCodeMap = new Map<string, string>();
const generatedTsMap = new Map<string, string>();

function extractVueAndSvelte(filePath: string): string {
  const ext = path.extname(filePath);
  if (!(ext === '.svelte' || ext === '.vue')) return filePath;

  const code = fs.readFileSync(filePath, 'utf8');
  originalCodeMap.set(filePath, code);

  const lines = code.split(/\r?\n/);
  let inScript = false;
  const contentLines = [];
  for (const line of lines) {
    const trimmed = line.trim();
    if (!inScript && /^<script\b/.test(trimmed)) {
      inScript = true;
      continue;
    }
    if (inScript && /^<\/script>/.test(trimmed)) {
      inScript = false;
      continue;
    }
    if (inScript) {
      contentLines.push(line);
    }
  }
  const tsCode = contentLines.join('\n');

  // Search for css.props in the original code (as it may be in a HTML tags)
  const propsRegex = /css\.props\s*\(([^)]*)\)\s*;?/g;
  const propsMatches = [];
  let match;

  // Search for css.props in tsCode
  while ((match = propsRegex.exec(tsCode))) {
    propsMatches.push(match[1].trim());
  }

  // Search for css.props in the entire original code
  propsRegex.lastIndex = 0; // reset index
  while ((match = propsRegex.exec(code))) {
    propsMatches.push(match[1].trim());
  }

  const allArgs = propsMatches.filter(Boolean);
  const mergedCall = allArgs.length
    ? `css.props(${[...new Set(allArgs)].join(', ')});\n`
    : '';

  // extract import section
  const importRegex = /^(\s*import\s[^;]+;\s*)+/m;
  const importMatch = tsCode.match(importRegex);
  const importSection = importMatch ? importMatch[0] : '';

  // extract style.create section
  const stylesRegex =
    /const\s+([A-Za-z_$][\w$]*)\s*=\s*css\.create\([\s\S]*?\);\s*/g;
  const stylesMatch = tsCode.match(stylesRegex);
  const stylesSection = stylesMatch ? stylesMatch[0] : '';

  // finale ts code
  let finalCode = '';

  // add import section
  if (importSection) {
    finalCode += importSection + '\n';
  }

  // add style.create section
  if (stylesSection) {
    finalCode += stylesSection + '\n';
  }

  // add mergedCall
  if (mergedCall) {
    finalCode += mergedCall;
  }

  // console.log('=== Debug Info ===');
  // console.log('File:', filePath);
  // console.log('Found props matches:', propsMatches);
  // console.log('Merged call:', mergedCall);
  // console.log('Final code:');
  // console.log(finalCode);
  // console.log('==================');

  const tsPath = filePath.replace(ext, '.ts');
  fs.writeFileSync(tsPath, finalCode, 'utf8');
  generatedTsMap.set(filePath, tsPath);
  return tsPath;
}

async function extractAndInjectStyleProps(filePath: string) {
  const original = fs.readFileSync(filePath, 'utf8');
  originalCodeMap.set(filePath, original);

  const regex = /css\.props\s*\(([^)]*)\)/g;
  const matches = [...original.matchAll(regex)];

  if (matches.length === 0) {
    console.log('No css.props found.');
    return;
  }

  const allArgs = matches.map((m) => m[1].trim()).filter(Boolean);
  const mergedCall = `css.props(${[...new Set(allArgs)].join(', ')});\n`;

  // Find all css.create
  const stylesRegex =
    /const\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\s*=\s*css\.create\([\s\S]*?\);\s*/g;
  const stylesMatches = [...original.matchAll(stylesRegex)];

  const importRegex = /^(import\s[^()]+;\s*)+/m;
  const importMatch = original.match(importRegex);

  let insertIndex = 0;

  // If css.create is found, insert after the last css.create
  if (stylesMatches.length > 0) {
    const lastStylesMatch = stylesMatches[stylesMatches.length - 1];
    insertIndex = (lastStylesMatch.index as number) + lastStylesMatch[0].length;
  }
  // If css.create is not found, insert it immediately after the import statement.
  else if (importMatch) {
    insertIndex = importMatch[0].length;
  }

  const finalCode =
    original.slice(0, insertIndex) +
    '\n' +
    mergedCall +
    original.slice(insertIndex);

  fs.writeFileSync(filePath, finalCode, 'utf8');
}

async function restoreAllOriginals() {
  for (const [originalPath, genPath] of generatedTsMap.entries()) {
    if (genPath !== originalPath && fs.existsSync(genPath)) {
      fs.unlinkSync(genPath); // Delete only the files generated by conversion from /.svelte and .vue to .ts
    }
  }
  generatedTsMap.clear();

  // Write all originalCodeMaps back to the original files from JSX/TSX/JS/TS
  for (const [filePath, backup] of originalCodeMap.entries()) {
    fs.writeFileSync(filePath, backup, 'utf8');
  }
  originalCodeMap.clear();
}

module.exports = {
  extractAndInjectStyleProps,
  restoreAllOriginals,
  extractVueAndSvelte,
  originalCodeMap,
};
