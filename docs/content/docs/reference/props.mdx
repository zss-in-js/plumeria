---
title: 'props'
description: 'API reference for the `props` function'
---

The `css.props()` function returns `styleObject` as `hashedClassName` together while **filtering out falsy values** like `undefined`, `false`, or `null`. It is useful when conditionally combining styles.

```ts title="TypeScript"
import { css } from '@plumeria/core';

const styles = css.create({
  one: {
    display: 'flex',
    justifyContent: 'space-between',
  },
  two: {
    fontSize: '14px',
    color: '#606060',
  },
});

const className = css.props(styles.one, styles.two);  // [!code ++]
```

## Prohibit intermediate code
Props compilation is performed by strictly deleting all intermediate code except `import` `css.create()` `css.props()`.
For example, static string literals like the one below will remain when the file in which css.props exists is compiled.

```tsx
// Allowed static string literal variables
const MD = "@media (max-width: 768px)"

const styles = css.create({
  responsive: {
    [MD]: {
      scale: 0.8,
    },
  },
});

return (
    <div className={css.props(styles.responsive)} />
)
```

The easiest way to follow the DRY principle is to make it a constant using defineConsts.
```tsx
import { css } from "@plumeria/core";
import { breakpoints } from "lib/mediaQuery";

const styles = css.create({
  responsive: {
    [breakpoints.md]: {  // [!code ++] Work
      scale: 0.8,
    },
  },
});

return (
    <div className={css.props(styles.responsive)} />
)
```
API calls such as `keyframes` and `defineConsts` (excluding global) must be created in separate files and cannot be written in the same file scope as css.props. Therefore, `defineConsts` `defineVars` `defineTheme` `keyframes` require imports.

<Callout title="Good to know">
If you create a separate styles file, these compilation restrictions do not apply and you can freely place APIs in the file. This is the difference between writing them in the same file and creating a separate file.
</Callout>


## Extract

The following is extracted at compile time and executed as ts code. (Vue and Svelte also execute as ts.)

```tsx
import { css } from "@plumeria/core";

const styless = css.create({
  responsive: {
    ["@media (max-width: 768px)"]: {
      scale: 0.8,
    },
  },
});

css.props(styless.responsive);
```

## Usage Patterns

### Conditional styles

Only truthy values are preserved.

```ts
const isActive = true;

const className = css.props(
  styles.one,
  isActive && styles.two
);
```

### With ternary

```ts
const className = css.props(
  isDark ? styles.dark : styles.light,
  isHovered && styles.hovered
);
```

---

## Return value
Returns a single hashes string of space-separated styleObject, ignoring falsy inputs:

```ts
css.props(styles.one, false, undefined, styles.two);
```


## See Also

<Callout title="Good to know">
  Since falsy values are filtered out, you can use logical and, ternary
  operators, etc. in argument expressions.  
  Nested ternary operators are not supported as this would require complex parsing.
</Callout>

### More

<Cards>
  <Card title="See more about create" href="/docs/reference/create" />
</Cards>
