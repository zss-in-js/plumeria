---
title: 'Thinking in Plumeria'
---

---

## Type-Driven design
```json title="package.json"
{
  "name": "@plumeria/core",
  "main": "types/css.d.ts",
  "module": "types/css.d.ts",
  "types": "types/css.d.ts",
  "files": [
    "types/"
  ],
}
```
Typical CSS-in-JS solutions use several kilobytes in initial bundle size. This library completely replaces type calls and is complete with just type definitions and plugins.
Developers simply extend the type definition arguments as **schemas**, so no JS parsing is required and there are no memory allocation costs.

## How It Works

Write styles with TypeScript autocomplete and type safety:
```tsx title="Before build"
import * as css from "@plumeria/core";

const styles = css.create({
  text: {
    fontSize: 12,
    color: 'navy',
  },
  size: {
    width: 120,
  },
});

<div className={css.props(styles.text, styles.size)} />
```

The build plugin transforms this into pure atomic CSS:
```tsx title="After build"
// All imports and style objects removed
<div className="xhrr6ses xvbwmxqp xhk51flp" />
```
---

## The Type-Driven Advantage

By treating styles as **type schemas** instead of runtime objects:
- No JavaScript bundle
- No JavaScript runtime
- No JavaScript parsing overhead
- No memory allocation for style objects
- Tree-shaking removes all framework code
- Only CSS class names remain in production